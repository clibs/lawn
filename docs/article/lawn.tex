\documentclass[twocolumn,a4paper]{article}

\usepackage{
	graphicx,
	amssymb,
}
\newcommand{\backtrackarrow}{\rotatebox[origin=c]{-90}{$\curvearrowleft$}}

\newcommand{\complexity}[5]{
\begin{table}[h!]
	\begin{center}
		\begin{tabular}{l|c}
			\textbf{Operation} & \textbf{Complexity} \\
			\hline
			\textit{StartTimer} & $O(#1)$  \\
			\textit{PerTick} & $O(#2)$ \\
			\textit{DeleteTimer} & $O(#3)$ \\
			\textit{TimerExpired} & $O(#4)$ \\
		\end{tabular}
		\caption{Time Complexity for #5 scheme}
%		\label{tab:table1}
	\end{center}
\end{table}
}

\newcommand{\advcomplexity}[9]{
\begin{table}[h!]
	\begin{center}
		\begin{tabular}{l|c|c}
			%& \multicolumn{2}{c}{\textbf{Case}} \\
			\textbf{Operation} & \textbf{Worst} & \textbf{Average} \\
			\hline
			\textit{StartTimer} & $O(#1)$ & $O(#2)$ \\
			\textit{PerTick} & $O(#3)$ & $O(#4)$ \\
			\textit{DeleteTimer} & $O(#5)$ & $O(#6)$ \\
			\textit{TimerExpired} & $O(#7)$ & $O(#8)$ \\
		\end{tabular}
		\caption{Runtime Complexity for #9 scheme}
		\label{tab:table1}
	\end{center}
\end{table}
}

\title{Lawn: an Unbound Low Latency Timer Data Structures for Large Scale Systems} 

\author{
	\textsc{Adam Lev-Libfeld} \\[1ex]
	\normalsize Tamar Labs \\
	\normalsize Tel-Aviv, Israel \\
	\normalsize{adam@tamarlabs.com}
}
\date{\today}


\begin{document}

\maketitle

\begin{abstract}
\textbf{\noindent As demand for Real-Time applications rise among 
the general public, the importance of enabling large scale, unbound algorithms to solve conventional problems with low to no latency is critical for product viability Timers algorithms are prevalent in the core mechanisms behind of operating systems, network protocol implementation, stream processing and several data base capabilities This paper presents an algorithm for a low latency, unbound range timer structure, based upon the well excepted Timing Wheel algorithm. Using a set of queues hashed by TTL, the algorithm allows for simpler implementation, minimal overhead and no degradation in performance in comparison to current state of the algorithms under typical use cases.}
\linebreak \linebreak
\textbf{\textit{Index Terms -} Stream Processing, Timer Wheel, Dehydrator, Callout facilities, protocol implementations, Timers, Timer Facilities.}
\end{abstract}


\section{Introduction}

\section{Model}
In similar manner to previous work\cite{TW}, the model discussed in this paper shall consist of the following components, each corresponding with a different stage in the life cycle of a timer in the data store:
\begin{center}
	$
	StartTimer \linebreak 
	\downarrow \linebreak  
	PerTickBookkeeping \hspace{1mm} \backtrackarrow \linebreak 
	\swarrow  \hspace{15pt}  \searrow \linebreak 
	DeleteTimer \hspace{15pt} TimerExpired
	$
	\vspace{3pt}
\end{center}
\paragraph{StartTimer(TTL,timerId\{,Payload\}):} This routine is called by the client to start a timer that will expire in after the TTL has passed. The client is also expected to supply a \textit{timer ID} in order to distinguish it from other timers in the data store. Some implementations also allow the client to provide a \textit{Payload}, usually some form of a callback action to be performed or data to be returned on timer expiration.

\paragraph{PerTickBookkeeping:} This routing encompasses all the actions, operation and callbacks to be performed as part of timer management and  expiration check every interval as determined by the data store granularity. Upon discovery of an outstanding timer to expire \textit{TimerExpired} will be initiated by this routine.

\paragraph{DeleteTimer(timerId):} The client may call this utility routine in order to remove from the data store an outstanding timer (corresponding with a given \textit{timer ID}), this is done by calling \textit{TimerExpired} for the requested timer before \textit{PerTickBookkeeping} had marked it to be expired.

\paragraph{TimerExpired(timerId):} Internally invoked by either \textit{PerTickBookkeeping} or \textit{DeleteTimer} this routine entails all actions and operations needed in order to remove all traces of the timer corresponding with a given \textit{timer ID} from the data store and invoking the any callbacks that were provided as \textit{Payload} during the \textit{StartTimer} routine.

\vspace{5mm}

Since payload and callback behavior varies significantly between different data store implementations, the store of such data can be achieved for $ O(1) $ using a simple hash map, and the handling of such callbacks can be done in a discrete, highly (or even embarrassingly) parallel this paper will disregard this aspect of timer stores.

% \vspace{5mm}

\subsection{Performance Notation}

the following notation would be used for all runtime and space complexity demarcations: \\
\indent\textbf{n :}The total number of timers in the data store.\\
\indent\textbf{t :}The total number of different TTLs in the data store. \\

\vspace{15mm}



for breverty and readabuility sake this paper will notate the 
% \textit{StartTimer}, \textit{PerTickBookkeeping}, \textit{DeleteTimer}, \textit{TimerExpired}

\section{Method}
this is how i will compare things

\section{Previous Work in light of Scale}

\subsection{Lists, Queues \& Hash Maps}
simple and popular


\subsection{Timer Wheel}
best, but bounded

\subsubsection{Assumptions and Constraints :}

\subsubsection{Algorithm :}


\advcomplexity{1}{1}{1}{1}{1}{1}{n}{1}{the Hashed Timer Wheel}


\subsubsection{Variants :}

\paragraph{Hashed :}
prevalent for high load systems, including Unix kernel



\section{The Lawn Data Structure}

\subsection{Intended Use Cases}

\paragraph{Assumptions and Constraints :}

\subsection{Algorithm}



\paragraph{Space and Runtime Complexity :}

\advcomplexity{1}{1}{t}{1}{1}{1}{1}{1}{the Lawn}

\section{Comparison and Reflection}

\section{An Algorithmic View}

\section{Conclusion}

\bibliographystyle{plain}
\bibliography{lawn}

\end{document}


c