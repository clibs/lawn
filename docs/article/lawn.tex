\documentclass[twocolumn,a4paper]{article}

\usepackage{
	graphicx,
	amssymb,
}
\newcommand{\backtrackarrow}{\rotatebox[origin=c]{-90}{$\curvearrowleft$}}

\title{Lawn - an Unbound Low Latancy Timer Data Structure for Large Scale Systems} 

\author{
	\textsc{Adam Lev-Libfeld} \\[1ex]
	\normalsize Tamar Labs \\
	\normalsize Tel-Aviv, Israel \\
	\normalsize{adam@tamarlabs.com}
}
\date{\today}


\begin{document}

\maketitle

\begin{abstract}
\textbf{\noindent As demand for Real-Time applications rise among 
the general public, the importance of enabling large scale, unbound algorithms to solve conventional problems with low to no latency is critical for product viability Timers algorithms are prevalent in the core mechanisms behind of operating systems, network protocol implementation, stream processing and several data base capabilities This paper presents an algorithm for a low latency, unbound range timer structure, based upon the well excepted Timing Wheel algorithm. Using a set of queues hashed by TTL, the algorithm allows for simpler implementation, minimal overhead and no degradation in performance in comparison to current state of the algorithms under typical use cases.}
\linebreak \linebreak
\textbf{\textit{Index Terms -} Stream Processing, Timer Wheel, Dehydrator, Callout facilities, protocol implementations, Timers, Timer Facilities.}
\end{abstract}


\section{Introduction}

\section{Model}
In similar manner to previous work\cite{TW}, the model discussed in this paper shall consist of the following components, each corresponding with a different stage in the life cycle of a timer in the data store:
\begin{center}
	$
	StartTimer \linebreak 
	\downarrow \linebreak  
	PerTickBookkeeping \hspace{1mm} \backtrackarrow \linebreak 
	\swarrow  \hspace{15pt}  \searrow \linebreak 
	DeleteTimer \hspace{15pt} TimerExpired
	$
	\vspace{3pt}
\end{center}
\paragraph{StartTimer(TTL,timerId\{,Payload\}):} This routine is called by the client to start a timer that will expire in after the TTL has passed. The client is also expected to supply a \textit{timer ID} in order to distinguish it from other timers in the data store. Some implementations also allow the client to provide a \textit{Payload}, usually some form of a callback action to be performed or data to be returned on timer expiration.

\paragraph{PerTickBookkeeping:} This routing encompasses all the actions, operation and callbacks to be performed as part of timer management and  expiration check every interval as determined by the data store granularity. Upon discovery of an outstanding timer to expire \textit{TimerExpired} will be initiated by this routine.

\paragraph{DeleteTimer(timerId):} The client may call this utility routine in order to remove from the data store an outstanding timer (corresponding with a given \textit{timer ID}), this is done by calling \textit{TimerExpired} for the requested timer before \textit{PerTickBookkeeping} had marked it to be expired.

\paragraph{TimerExpired(timerId):} Internally invoked by either \textit{PerTickBookkeeping} or \textit{DeleteTimer} this routine entails all actions and operations needed in order to remove all traces of the timer corresponding with a given \textit{timer ID} from the data store and invoking the any callbacks that were provided as \textit{Payload} during the \textit{StartTimer} routine.

\vspace{5mm}

Since payload and callback behavior varies significantly between different data store implementations, the store of such data can be achieved for $ O(1) $ using a simple hash map, and the handling of such callbacks is highly (or even embarrassingly) parallel this paper will disregard this aspect of timer stores.

% \vspace{5mm}

% \paragraph{Performance Notation}, for breverty and readabuility sake this paper will notate the 
% \textit{StartTimer}, \textit{PerTickBookkeeping}, \textit{DeleteTimer}, \textit{TimerExpired}

\section{Exsiting Timer Store Schemes}


\subsection{Naive}

usually a implemented by list, array, or vector of some sort
\paragraph{Assumpions and Constraints :}

\subsubsection{Algorithm :}

Due to the manner in which the store is traversed in search of expired would benefit greatly from low TTL variance. Close TTLs m

\begin{table}[h!]
	\begin{center}
		
		\begin{tabular}{l|c|c}
			\textfb{Operation} & \textfb{Worst Case} & \textfb{Avarage Case} \\
			\hline
			\textit{StartTimer} & $O(?)$ & $O(?)$
			\textit{PerTickBookkeeping} & $O(?)$ & $O(?)$
			\textit{DeleteTimer} & $O(?)$ & $O(?)$
			\textit{TimerExpired} & $O(?)$ & $O(?)$
		\end{tabular}
		\caption{Runtime Complexity for the queue timer store scheme}
		\label{tab:table1}
	\end{center}
\end{table}

space complexity



\subsubsection{Varients :}

\paragraph{Queue :}
a bit better, makes searching faster


\subsection{Sorted}

\paragraph{Assumpions and Constraints :}

\subsubsection{Algorithm :}

Due to the manner in which the store is traversed in search of expired would benefit greatly from low TTL variance. Close TTLs m

\begin{table}[h!]
	\begin{center}
		
		\begin{tabular}{l|c|c}
			\textfb{Operation} & \textfb{Worst Case} & \textfb{Avarage Case} \\
			\hline
			\textit{StartTimer} & $O(?)$ & $O(?)$
			\textit{PerTickBookkeeping} & $O(?)$ & $O(?)$
			\textit{DeleteTimer} & $O(?)$ & $O(?)$
			\textit{TimerExpired} & $O(?)$ & $O(?)$
		\end{tabular}
		\caption{Runtime Complexity for the queue timer store scheme}
		\label{tab:table1}
	\end{center}
\end{table}

space complexity



\subsubsection{Varients :}

\paragraph{Sorted Queue :}

\paragraph{Versioned Hash :}
very popular improves complexity from $ $



\subsection{Timer Wheel}

\subsubsection{Assumpions and Constraints :}

\subsubsection{Algorithm :}

\begin{table}[h!]
	\begin{center}
		
		\begin{tabular}{l|c|c}
			\textfb{Operation} & \textfb{Worst Case} & \textfb{Avarage Case} \\
			\hline
			\textit{StartTimer} & $O(?)$ & $O(?)$
			\textit{PerTickBookkeeping} & $O(?)$ & $O(?)$
			\textit{DeleteTimer} & $O(?)$ & $O(?)$
			\textit{TimerExpired} & $O(?)$ & $O(?)$
		\end{tabular}
		\caption{Runtime Complexity for the queue timer store scheme}
		\label{tab:table1}
	\end{center}
\end{table}

space complexity


\subsubsection{Varients :}

\paragraph{Hashed :}
prevelent for high load systems, including Unix kernel



\section{The Lawn Data Structure}

\subsection{Intended Use Case}

\subsection{Algorithm}

\paragraph{Assumpions and Constraints :}

\paragraph{Space and Runtime Complexity :}

\section{Comparison and Reflection}

\section{An Algorithmic View}

\section{Conclusion}

\bibliographystyle{plain}
\bibliography{lawn}

\end{document}


