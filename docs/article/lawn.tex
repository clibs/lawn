\documentclass[twocolumn,a4paper]{article}

\usepackage{
	graphicx,
	amssymb,
	algorithm,
	algorithmicx,
}

\usepackage[noend]{algpseudocode}

\newcommand*\Let[2]{\State #1 $\gets$ #2}
\algrenewcommand\algorithmicrequire{\textbf{Precondition:}}
\algrenewcommand\algorithmicensure{\textbf{Postcondition:}}

\newcommand{\backtrackarrow}{\rotatebox[origin=c]{-90}{$\curvearrowleft$}}

\newcommand{\complexity}[5]{
\begin{table}[h!]
	\begin{center}
		\begin{tabular}{l|c}
			\textbf{Operation} & \textbf{Complexity} \\
			\hline
			\textit{StartTimer} & $O(#1)$  \\
			\textit{PerTick} & $O(#2)$ \\
			\textit{DeleteTimer} & $O(#3)$ \\
			\textit{TimerExpired} & $O(#4)$ \\
		\end{tabular}
		\caption{Time Complexity for #5 scheme}
%		\label{tab:table1}
	\end{center}
\end{table}
}

\newcommand{\advcomplexity}[9]{
\begin{table}[h!]
	\begin{center}
		\begin{tabular}{l|c|c}
			%& \multicolumn{2}{c}{\textbf{Case}} \\
			\textbf{Operation} & \textbf{Worst} & \textbf{Mean} \\
			\hline
			\textit{StartTimer} & $O(#1)$ & $O(#2)$ \\
			\textit{PerTick} & $O(#3)$ & $O(#4)$ \\
			\textit{DeleteTimer} & $O(#5)$ & $O(#6)$ \\
			\textit{TimerExpired} & $O(#7)$ & $O(#8)$ \\
		\end{tabular}
		\caption{Runtime Complexity for #9 scheme}
		\label{tab:table1}
	\end{center}
\end{table}
}

\title{Lawn: an Unbound Low Latency Timer Data Structure for Large Scale, High Throughput Systems} 

\author{
	\textsc{Adam Lev-Libfeld} \\[1ex]
	\normalsize Tamar Labs \\
	\normalsize Tel-Aviv, Israel \\
	\normalsize{adam@tamarlabs.com}
}
\date{\today}


\begin{document}

\maketitle

\begin{abstract}
\textbf{\noindent As demand for Real-Time applications rise among the general public, the importance of enabling large-scale, unbound algorithms to solve conventional problems with low to no latency is critical for product viability Timers algorithms are prevalent in the core mechanisms behind of operating systems, network protocol implementation, stream processing, and several database capabilities This paper presents an algorithm for a low latency, unbound range timer structure, based upon the well excepted Timing Wheel algorithm. Using a set of queues hashed by TTL, the algorithm allows for a simpler implementation, minimal overhead and no degradation in performance in comparison to the current state of the algorithms under typical use cases.}
\linebreak \linebreak
\textbf{\textit{Index Terms -} Stream Processing, Timing Wheel, Dehydrator, Callout facilities, protocol implementations, Timers, Timer Facilities.}
\end{abstract}


\section{Introduction}

\section{Model}
In similar manner to previous work\cite{TW}, the model discussed in this paper shall consist of the following components, each corresponding with a different stage in the life cycle of a timer in the data store:
\begin{center}
	$
	StartTimer \linebreak 
	\downarrow \linebreak  
	PerTickBookkeeping \hspace{1mm} \backtrackarrow \linebreak 
	\swarrow  \hspace{15pt}  \searrow \linebreak 
	DeleteTimer \hspace{15pt} TimerExpired
	$
	\vspace{3pt}
\end{center}
\paragraph{StartTimer(TTL,timerId\{,Payload\}):} This routine is called by the client to start a timer that will expire in after the TTL has passed. The client is also expected to supply a \textit{timer ID} in order to distinguish it from other timers in the data store. Some implementations also allow the client to provide a \textit{Payload}, usually some form of a callback action to be performed or data to be returned on timer expiration.

\paragraph{PerTickBookkeeping():} This routine encompasses all the actions, operation and callbacks to be performed as part of timer management and  expiration check every interval as determined by the data store granularity. Upon discovery of an outstanding timer to expire \textit{TimerExpired} will be initiated by this routine.

\paragraph{DeleteTimer(timerId):} The client may call this utility routine in order to remove from the data store an outstanding timer (corresponding with a given \textit{timer ID}), this is done by calling \textit{TimerExpired} for the requested timer before \textit{PerTickBookkeeping} had marked it to be expired.

\paragraph{TimerExpired(timerId):} Internally invoked by either \textit{PerTickBookkeeping} or \textit{DeleteTimer} this routine entails all actions and operations needed in order to remove all traces of the timer corresponding with a given \textit{timer ID} from the data store and invoking the any callbacks that were provided as \textit{Payload} during the \textit{StartTimer} routine.

\vspace{5mm}

Since payload and callback behavior varies significantly between different data store implementations, the store of such data can be achieved for $ O(1) $ using a simple hash map, and the handling of such callbacks can be done in a discrete, highly (or even embarrassingly) parallel this paper will disregard this aspect of timer stores.

% \vspace{5mm}

\section{Method}
In this paper we shall compare the algorithms in three manners:
\begin{enumerate}
	\item Theoretical analysis 
	\item High level Python implementation (version 2.7.14)
	\item Low level, highly optimized C implementation (compiled with gcc version 7.2.0)
\end{enumerate}
 Implemented using both Python and C\footnote{Source code is available here\cite{GH}. \textbf{Python} version 2.7.14 and \textbf{C} compiled with gcc version 7.2.0. }:

Results 
 (Python 2.7 and C) schemes algorithms where compared using three distinct techniques:
 
this is how i will compare things

\section{Previous Work in light of Scale}

\subsection{Lists, Queues \& Hash Maps}
simple and popular


\subsection{Hashed Timing Wheel}
best, but bounded

\paragraph{Assumptions and Constraints :}
The Hashed Timing Wheel was designed to be an all purpose timer storage solution for  


\advcomplexity{1}{1}{n}{1}{1}{1}{1}{1}{the Hashed Timing Wheel}


\section{The Lawn Data Structure}
 
\subsection{Intended Use Cases}

This algorithm was first developed during the writing of a large scale, Stream Processing geographic intersection product using a FastData\cite{GP} model. The data structure was to receive inputs from one or more systems that make use of a very limited range of TTLs in proportion to the number of concurrent timers they use. 

\paragraph{Assumptions and Constraints :}
As this algorithm was designed to operate as the core of a dehydration utility for a single  FastData application, where TTLs are usually discrete and variance is low it is intended for use under the assumptions that: 
\begin{center}
	$ Unique\ TTL\ Count \ll Concurrent\ Timer\ Count $
\end{center}
Assuming that most timers will have a TTL from within a small set of options will enable the application of the core concept behind the algorithm - TTL bucketing. 

\subsubsection{The Data Structure}
Lawn is, in it's core, a hash of sorted sets\footnote{These are the TTL 'buckets'}, much like Timing Wheel. The main difference is the key used for hashing these sets is the timer TTL. Meaning different timers will be stored in the same set based only on their TTL regardless of arrival time. Within each set the timers are naturally sorted by time  of arrival - effectively using the set as a queue. Using this queuing methodology based on TTL, we ensure that whenever a new timer is added to a queue, every other timer that is already there should be expired before the current one, since it is already in the queue and have the same TTL.

The data structure is analogous to blades of grass (hence the name) - each blade grows from the roots up, and periodically (in our case every $Tick$) the overgrown tops of the grass blades (the expired timers) are maintained by mewing the lawn to a desired level (current time).       
 
\subsection{Algorithm}
\begin{algorithm}
	\caption{The Lawn Data Store \label{alg:lawn}}
	\begin{algorithmic}[1]
		\Require{\\$id$ - a unique identifier of a timer.\\ $ttl$ - a whole product of $Tick Resolution$ representing the amount of time to wait before triggering the given timer $payload\_action$ action.\\$payload\_action$ - the action to perform upon timer expiration.\\\textit{current time} - the local time of the system as a whole product of $Tick Resolution$}
		
		\Statex
		\Function{InitLawn}{{}}
			\Let{TTLHash}{new empty hash set}
			\Let{TimerHash}{new empty hash set}
			\Let{$closest\ expiration$}{0}
		\EndFunction
		\Statex
		\Function{StartTimer}{$id$, $ttl$, $payload\_action$}
			\Let{$endtime$}{current time + $ttl$} %\Comment{current time: the local time of the system as a whole product of $Tick Resolution$}
			\Let{$T$}{$(endtime,ttl,id,payload\_action)$}
			\Let{TimerHash[$id$]}{$T$}
			\If{$ttl \notin$ TTLHash}
				\Let{TTLHash[$ttl$]}{new empty queue}
			\EndIf
			\State{TTLHash[$ttl$].\textbf{insert}($T$)}
			\If{$endtime < closest\ expiration$}
				\Let{$closest\ expiration$}{$endtime$}
			\EndIf
		\EndFunction
		\Statex
		\Function{PerTickBookkeeping}{{}}
		\If{current time $ < closest\ expiration$}
		\State{\textbf{return}}
		\EndIf
		\For{$queue \in $TTLHash}
			\Let{$T$}{\textbf{peek}($queue$)}
			\While{$T_{endtime} < $ current time}
				\State{\textbf{TimerExpired}($T_{id}$)}
				\Let{$T$}{\textbf{peek}($queue$)}
			\EndWhile
			\If{$closest\ expiration$ = 0 \newline \textbf{or} $T_{endtime} < closest\ expiration$}
				\Let{$closest\ expiration$}{$T_{endtime}$}
			\EndIf
		\EndFor
		\EndFunction
		\Statex
		\Function{TimerExpired}{$id$}
			\Let{$T$}{TimerHash[$id$]}
			\State{\textbf{DeleteTimer}($T$)} 
			\State{\textbf{do} $T_{payload\_action}$}
		\EndFunction
		\Statex
		\Function{DeleteTimer}{$id$}
			\Let{$T$}{TimerHash[$id$]}
			\If{$T_{endtime} = closest\ expiration$}
			\Let{$closest\ expiration$}{0}
			\EndIf
			\State{TTLHash[$T_{ttl}$].\textbf{remove}($T$)} 
			\State{TimerHash.\textbf{remove}($T$)} 
			\If{TTLHash[$T_{ttl}$] is empty}
				\State{TTLHash.\textbf{remove}[$ttl$]}
			\EndIf
		\EndFunction
		
	\end{algorithmic}
\end{algorithm}

\subsubsection{Correctness}
%Given Timer $T$ with TTL $TTL$ that is started (using the \textit{StartTimer} operation) at time $t$,  
To prove correctness of the algorithm,  it should be demonstrated that for each Timer, it is expired (by the calling the \textit{TimerExpired} operation or it) within \textit{Tick} of it's intended TTL. As the algorithm pivots around the TTL bucketing concept, where in each timer is stored exactly once in it's corresponding bucket, and these buckets are independent of each other, it is sufficient to demonstrating correctness for all timers of a bucket, That is:
\begin{center}
	$\forall \quad T^{start}, T^{ttl} \in \mathbb{N} \quad \exists \quad T^{stop} \in \mathbb{N} : T^{stop}-T^{start} \approx T^{ttl}$
\end{center}

Alternatively, we can use the sorting analogy made by G. Varghese et al.\cite{TW} to show that given two triggers $T_n, T_m$: 

\begin{center}
	$\forall \quad T_n, T_m \quad | \quad T^{start}_n<T^{start}_m,  T^{ttl}_n = T^{ttl}_m \quad \exists\quad T^{stop}_n, T^{stop}_m  \Rightarrow T^{stop}_n < T^{stop}_m$
\end{center}

Taking into account that each bucket only contains triggers with the same TTL we can simplify the above:

\begin{center}
	$\forall \quad T_n, T_m \quad | \quad T^{start}_n<T^{start}_m \Rightarrow T^{stop}_n < T^{stop}_m$
\end{center}

Which, due to the bucket being a sorted set, ordered by $T^{start}$ and triggers being expired by bucket order from old to new is self-evident, and we arrived at a proof.

\subsubsection{Space and Runtime Complexity}
The Lawn data structure is dense by design, as every timer is stored exactly once, a new trigger will add at most a single TTL bucket and empty TTL buckets are always removed, the data structure footprint will only grow linearly with the number of timers. Hence, overall space complexity is linear to the number of timers ($O(n)$). 

\advcomplexity{1}{1}{n}{t\sim1}{1}{1}{1}{1}{the Lawn}

Since the PerTickBookkeeping routine of Lawn iterates over the top item of all known TTL buckets on every expiration cycle (where at least one timer is expected to expire), it's mean case runtime is linear to $t$ (the number of different TTLs) and seems to be lacking even in comparison to more primitive implementations of timer storage. That said, with an added assumption that the TTL set size is roughly constant, or at worst asymptotically smaller then the number of timers\footnote{The assumptions is derived from this data structure being designed around serving other computer systems, which often have either a single TTL used repeatedly, their TTLs chosen from a list of hard coded values or derived from a simple mathematical operation (sliding windows are a good example of this method, using fixed increments or powers of 2 to determine TTLs)}, we can regard this operation as constant time.



Space complexity is $O(n)$ as , since  and possibly an entry in the timer hash.

\section{Comparison and Reflection}

to compare:
hashed heap
vs
Hashed Timing Wheel
vs 
Lawn

\section{An Algorithmic View}

\subsubsection{Multiprocessing}
Highly parallel (splitting by queue) and does not requires a lighter use of semaphores  than other queue based schemes

\section{Conclusion}

\bibliographystyle{acm}
\bibliography{lawn}

\end{document}


c